package.json
{
  "name": "restapi",
  "version": "0.0.0",
  "license": "MIT",
  "scripts": {
    "ng": "ng",
    "start": "node dist/server",
    "build": "ng build --prod",
    "test": "ng test",
    "lint": "ng lint",
    "e2e": "ng e2e",
    "webpack:server": "webpack --config webpack.server.config.js --progress --colors",
    "main-server": "ng run restapi:server"
  },
  "private": true,
  "dependencies": {
    "@angular/animations": "^6.1.6",
    "@angular/cdk": "^6.4.7",
    "@angular/common": "^6.1.6",
    "@angular/compiler": "^6.1.6",
    "@angular/core": "^6.1.6",
    "@angular/forms": "^6.1.6",
    "@angular/http": "^6.1.6",
    "@angular/material": "^6.4.7",
    "@angular/platform-browser": "^6.1.6",
    "@angular/platform-browser-dynamic": "^6.1.6",
    "@angular/platform-server": "^6.1.6",
    "@angular/router": "^6.1.6",
    "@nguniversal/express-engine": "^6.1.0",
    "@nguniversal/module-map-ngfactory-loader": "^6.1.0",
    "body-parser": "^1.18.3",
    "bootstrap": "^4.1.3",
    "core-js": "^2.4.1",
    "cors": "^2.8.4",
    "express": "^4.16.3",
    "jquery": "^3.3.1",
    "popper.js": "^1.14.4",
    "request": "^2.88.0",
    "rxjs": "^6.3.1",
    "zone.js": "^0.8.26"
  },
  "devDependencies": {
    "@angular-devkit/build-angular": "~0.7.0",
    "@angular/cli": "6.1.5",
    "@angular/compiler-cli": "^6.1.6",
    "@angular/language-service": "^6.1.6",
    "@types/jasmine": "~2.8.8",
    "@types/jasminewd2": "~2.0.3",
    "@types/node": "~10.9.4",
    "codelyzer": "^4.4.4",
    "jasmine-core": "~3.2.1",
    "jasmine-spec-reporter": "~4.2.1",
    "karma": "~3.0.0",
    "karma-chrome-launcher": "~2.2.0",
    "karma-cli": "~1.0.1",
    "karma-coverage-istanbul-reporter": "^2.0.3",
    "karma-jasmine": "~1.1.2",
    "karma-jasmine-html-reporter": "^0.2.2",
    "protractor": "~5.4.0",
    "ts-loader": "^5.0.0",
    "ts-node": "~7.0.1",
    "tslint": "~5.11.0",
    "typescript": "^2.9.2",
    "webpack-cli": "^3.1.0"
  }
}

app.module.ts
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { NgModule } from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MatCardModule,
        MatFormFieldModule,
        MatInputModule,
        MatButtonModule,
        MatSidenavModule,
        MatListModule,
        MatIconModule,
        MatToolbarModule,
        MatSelectModule,
        MatMenuModule,
        MatTabsModule,
        MatGridListModule,
        MatDividerModule,
        MatAutocompleteModule,
        MatSnackBarModule} from '@angular/material';

import { AppComponent } from './app.component';
import { ApiDetailsComponent } from './api-details/api-details.component';
import { HttpClientModule } from '@angular/common/http';
import { HighlightDirective } from './highlight.directive';
import { MenuComponent } from './menu/menu.component';
import { LayoutModule } from '@angular/cdk/layout';
import { MenuContentComponent } from './menu/menu-content/menu-content.component';
import { SearchComponent } from './menu/search/search.component';
import { TestComponent } from './test/test.component';


@NgModule({
  declarations: [
    AppComponent,
    ApiDetailsComponent,
    HighlightDirective,
    MenuComponent,
    MenuContentComponent,
    SearchComponent,
    TestComponent
  ],
  imports: [
    BrowserModule.withServerTransition({appId: 'restapi'}),
    BrowserAnimationsModule,
    HttpClientModule,
    MatCardModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatSidenavModule,
    MatListModule,
    MatIconModule,
    MatToolbarModule,
    MatSelectModule,
    MatMenuModule,
    MatTabsModule,
    MatDividerModule,
    MatGridListModule,
    MatAutocompleteModule,
    MatSnackBarModule,
    ReactiveFormsModule,
    FormsModule,
    LayoutModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }


app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'app';

}

app.component.html
<app-menu></app-menu>

shared/api.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';

import { Observable, Subject } from 'rxjs';
import { map } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class APIService {

  APIList = [];

  selectedAPIId = new Subject();

  menuItems = new Subject();

  names = new Subject();

  constructor(private http: HttpClient) { }

  fetchServicesList(): Observable<any> {
    return this.http.get('/server/services')
      .pipe(
        map((res: any) => {
          this.APIList = res;
          return true;
        })
      );
  }

  fetchMenuItems() {
    const items = [];
    this.APIList.slice().forEach((ele, idx) => {
      items.push({ name: ele.name, id: ele.id, expanded: false, services: [] });
      ele.services.forEach(service => {
        items[idx].services.push({ id: service.id, name: service.name });
      });
    });
    console.log(items);
    this.menuItems.next(items);
  }

  fetchMenuItemsBySearch(serviceName) {
    const items = [];
    let serviceList = [];
    this.APIList.slice().forEach(system => {
      serviceList = [];
      system.services.forEach(service => {
        if (service.name.toUpperCase().replace(/\s/g, '').includes(serviceName.toUpperCase().replace(/\s/g, ''))) {
          serviceList.push({ id: service.id, name: service.name });
        }
      });
      if (serviceList.length > 0) {
        items.push({ name: system.name, expanded: true, id: system.id, services: serviceList });
      }
    });
    this.menuItems.next(items);
    return items;
  }

  selectAPIByID(id) {
    this.selectedAPIId.next(id);
  }

  newService() {
    this.selectedAPIId.next();
  }

  fetchNamesById(id) {
    const systemId = id.split('_')[0];
    const serviceId = id.split('_')[1];
    const system: any = this.APIList.filter(sys => sys.id.toString() === systemId.toString()); // [systemId].name;
    const service: any = system[0].services.filter(srv => srv.id.toString() === serviceId.toString());
    return system[0].name + ' > ' + service[0].name;
  }

  fetchServiceNames() {
    const serviceNames = [];
    this.APIList.forEach( (sys, idx) => {
      serviceNames.push({ systemName: sys.name, serviceNames: []});
      sys.services.forEach( srv => {
        serviceNames[idx].serviceNames.push(srv.name);
      });
    });
    this.names.next(serviceNames);
  }

  fetchById(id) {
    const systemId = id.split('_')[0];
    const serviceId = id.split('_')[1];
    const system: any = this.APIList.filter(sys => sys.id.toString() === systemId.toString());
    const service: any = system[0].services.filter(srv => srv.id.toString() === serviceId.toString());
    return { name: system[0].name, id: system[0].id, service: service[0] };
  }

  save(data): Observable<any> {
    return this.http.post('/server/save', data)
      .pipe(
        map((res: any) => {
          this.APIList = res;
          this.fetchMenuItems();
          return res;
        })
      );
  }

  send(formdata): Observable<any> {
    console.log(formdata);
    return this.http.post('/server/send', formdata)
      .pipe(
        map( (res: Response) => {
          console.log(res);
          return res;
        })
      );

  }

  delete(id): Observable<any> {
    return this.http.post('/server/delete', { id: id })
      .pipe(
        map(res => {
          return res;
        })
      );
  }

}

api-details/api-details.component.ts
import { Component, OnInit, Input, Output } from '@angular/core';
import { FormGroup, FormControl, FormArray } from '@angular/forms';
import { APIService } from '../shared/api.service';
import { Observable } from 'rxjs';
import { MatSnackBar } from '@angular/material';

import { APIDetails } from './api-details.model';
import { map, startWith } from 'rxjs/operators';
import { EventEmitter } from '@angular/core';

@Component({
  selector: 'app-api-details',
  templateUrl: './api-details.component.html',
  styleUrls: ['./api-details.component.css']
})
export class ApiDetailsComponent implements OnInit {

  form: FormGroup;

  apiDetails: APIDetails;

  isSelected = false;

  newService = false;

  changeTabOnSend = 0;

  headermenu;

  serviceId;

  headers = [];

  newheader = false;

  methodOptions: string[] = ['GET', 'POST', 'PUT', 'DELETE', 'HEAD'];

  key: HTMLInputElement;

  headerKeyOptions: string[] = [
    'Accept', 'Accept-Charset', 'Accept-Encoding', 'Accept-Language', 'Accept-Datetime', 'Access-Control-Request-Method',
    'Access-Control-Request-Headers', 'Authorization', 'Cache-Control', 'Connection', 'Content-Length', 'Content-MD5',
    'Content-Type', 'Cookie', 'Date', 'Expect', 'Forwarded', 'From', 'Host', 'If-Match', 'If-Modified-Since',
    'If-None-Match', 'If-Range', 'If-Unmodified-Since', 'Max-Forwards', 'Origin', 'Pragma', 'Proxy-Authorization',
    'Range', 'Referer', 'TE', 'User-Agent', 'Upgrade', 'Via', 'Warning', 'Upgrade-Insecure-Requests', 'X-Requested-With',
    'DNT', 'X-Forwarded-For', 'X-Forwarded-Host', 'X-Forwarded-Proto', 'Front-End-Https', 'X-Http-Method-Override',
    'X-ATT-DeviceId', 'X-Wap-Profile', 'Proxy-Connection', 'X-UIDH', 'X-Csrf-Token', 'X-Request-ID', 'X-Correlation-ID', 'Save-Data'
  ];

  headerValueOptions: string[] = [
    'application/atom+xml', 'application/ecmascript', 'application/json', 'application/octet-stream', 'application/ogg',
    'application/pdf', 'application/postscript', 'application/rdf+xml', 'application/rss+xml', 'application/soap+xml',
    'application/font-woff', 'application/x-yaml', 'application/xhtml+xml', 'application/xml', 'application/xml-dtd',
    'application/xop+xml', 'application/zip', 'application/gzip', 'application/graphql', 'application/x-www-form-urlencoded',
    'image/gif', 'image/jpeg', 'image/pjpeg', 'image/png', 'image/svg+xml', 'image/tiff', 'message/http',
    'message/imdn+xml', 'message/partial', 'message/rfc822', 'multipart/mixed', 'multipart/alternative',
    'multipart/related', 'multipart/form-data', 'multipart/signed', 'multipart/encrypted', 'text/cmd',
    'text/css', 'text/csv', 'text/html', 'text/plain', 'text/vcard', 'text/xml'
  ];

  filterOptionsForMethod: Observable<string[]>;

  filterOptionsForHeaderKey: string[];

  filterOptionsForHeaderValue: string[];

  responseTime: String;

  statusCode: String;

  @Input() set serviceContent(content) {
    if (content === undefined) {
      this.newService = true;
    } else {
      this.serviceId = content;
      this.apiDetails = this.apiService.fetchById(content);
      this.headers = Object.keys(this.apiDetails.service.headers);
    }
    this.buildForm();
    this.isSelected = true;

  }

  @Output() delete = new EventEmitter();

  constructor(private apiService: APIService, private snackbar: MatSnackBar) { }

  ngOnInit() {
    this.responseTime = '--';
    this.statusCode = '--';
    this.filterOptionsForMethod = this.form.controls['method'].valueChanges
      .pipe(
        startWith(''),
        map(value => this.filter(value))
      );
  }

  buildForm() {
    let systemName = null;
    let systemId = null;
    let serviceName = null;
    let serviceId = null;
    let description = null;
    let url = null;
    let method = null;
    let response = null;
    let body = null;
    const _headers = new FormArray([]);


    if (!this.newService) {
      systemName = this.apiDetails.name;
      systemId = this.apiDetails.id;
      serviceName = this.apiDetails.service.name;
      serviceId = this.apiDetails.service.id;
      description = this.apiDetails.service.description;
      url = this.apiDetails.service.url;
      method = this.apiDetails.service.method;
      body = this.apiDetails.service.body,
      this.apiDetails.service.headers.forEach( header => {
        _headers.push( new FormGroup({
          key: new FormControl(header.key),
          value: new FormControl(header.value)
        }));
      });
      response = this.apiDetails.service.sampleResponse || null;
    } else {
      this.newService = false;
    }

    this.form = new FormGroup({
      systemName: new FormControl(systemName),
      systemId: new FormControl(systemId),
      serviceName: new FormControl(serviceName),
      serviceId: new FormControl(serviceId),
      description: new FormControl(description),
      url: new FormControl(url),
      method: new FormControl(method),
      body: new FormControl(body),
      headers: _headers,
      response: new FormControl(response)
    });

  }

  onTest() {
    this.changeTabOnSend = 1;
    this.apiService.send(this.form.value)
      .subscribe(
        res => {
          this.statusCode = res.statusCode;
          this.responseTime = res.time + 'ms';
          this.form.controls['response'].patchValue(JSON.stringify(res.body, undefined, 4));
        },
        err => this.form.controls['response'].patchValue(JSON.stringify(err, undefined, 4)));
  }

  onSave() {
    console.log(this.form.value);
    this.apiService.save(this.form.value)
      .subscribe(res => {
        this.snackbar.open('Saved.', null, {
          duration: 2000,
          horizontalPosition: 'right'
        });
      });
  }

  onNewHeader() {
    this.newheader = true;
  }

  onDeleteHeader(idx) {
    (<FormArray>this.form.get('headers')).removeAt(idx);
  }

  onAdd(key: HTMLInputElement, value: HTMLInputElement) {
    if (key.value !== '' && value.value !== '') {
      this.headers.push(key.value);
      (<FormArray>this.form.get('headers')).push(
        new FormGroup({
          key: new FormControl(key.value),
          value: new FormControl(value.value)
        })
      );
      key.value = '';
      value.value = '';
      this.newheader = false;
    }
  }

  onHeadersKey(event) {
    this.filterOptionsForHeaderKey = this.headerKeyOptions.filter(key => key.toLowerCase().includes(event.target.value));
  }

  onHeadersValue(event) {
    this.filterOptionsForHeaderValue = this.headerValueOptions.filter(val => val.toLowerCase().includes(event.target.value));
  }

  filter(val: string): string[] {
    return this.methodOptions.filter(option => option.toLowerCase().includes(val.toLowerCase()));
  }

  onDelete() {
    this.apiService.delete(this.apiDetails.id + '_' + this.apiDetails.service.id)
      .subscribe( res => {
        this.delete.emit('');
        this.snackbar.open('Deleted successfully.', null, {
          duration: 2000,
          horizontalPosition: 'right'
        });
      });
  }

}


api-details/api-details.model.ts
export class APIDetails {

  constructor(
    public name: string,
    public id: string,
    public service: Service
  ) { }
}

export class Headers {
  constructor( public key: string, public value: string) {}
}

export class Service {
  constructor(
    public name: string,
    public id: number,
    public description: string,
    public url: string,
    public method: String,
    public body: string,
    public headers: Headers[],
    public sampleRequest: string,
    public sampleResponse: string
  ) { }
}

api-detals/api-details.component.html
<form [formGroup]="form" (ngSubmit)="onSave()">
  <div class="mt-4">
    <mat-form-field class="col-md-2" appearance="outline">
      <mat-label for="method"> Method</mat-label>
      <input matInput type="text" name="method" formControlName="method" [matAutocomplete]="auto">
      <mat-autocomplete #auto="matAutocomplete">
        <mat-option *ngFor="let option of filterOptionsForMethod | async" [value]="option">
          {{option}}
        </mat-option>
      </mat-autocomplete>
    </mat-form-field>
    <mat-form-field class="col-md-9" appearance="outline">
      <mat-label for="url"> URL</mat-label>
      <input matInput type="text" name="url" formControlName="url">
    </mat-form-field>
    <button mat-stroked-button color="warn" type="button" (click)="onTest()">send</button>
  </div>
  <div class="mt-2" *ngIf="form.get('method').value === 'POST' || form.get('method').value === 'PUT'">
    <mat-form-field class="col-md-12" appearance="outline">
      <mat-label for="body">Body</mat-label>
      <textarea matInput name="body" rows="6" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" formControlName="body"></textarea>
    </mat-form-field>
  </div>
  <div class="col-md-12">
    <mat-tab-group [selectedIndex]="changeTabOnSend">
      <mat-tab label="Headers">
        <div class="mt-2">
          <div formArrayName="headers">
            <div *ngFor="let header of form.get('headers')['controls']; let i = index" [formGroupName]="i">
              <mat-form-field class="col-md-3" appearance="outline">
                <mat-label for="key"> Key </mat-label>
                <input matInput type="text" name="key" formControlName="key">
                <mat-autocomplete #headerskeyauto="matAutocomplete">
                  <mat-option *ngFor="let option of filterOptionsForHeaderKey" [value]="option">
                    {{option}}
                  </mat-option>
                </mat-autocomplete>
              </mat-form-field>
              <mat-form-field class="col-md-8" appearance="outline">
                <mat-label for="value"> Value </mat-label>
                <input matInput type="text" name="value" formControlName="value">
                <mat-autocomplete #headersvalueauto="matAutocomplete">
                  <mat-option *ngFor="let option of filterOptionsForHeaderValue" [value]="option">
                    {{option}}
                  </mat-option>
                </mat-autocomplete>
              </mat-form-field>
              <button mat-icon-button type="button" (click)="onDeleteHeader(i)">
                  <mat-icon color="warn">remove_circle</mat-icon>
                </button>
            </div>
          </div>
          <mat-form-field class="col-md-3" appearance="outline">
            <mat-label for="key"> Key </mat-label>
            <input matInput name="key" #headerkey (keyup)="onHeadersKey($event)" [matAutocomplete]="headerskeyauto">
            <mat-autocomplete #headerskeyauto="matAutocomplete">
              <mat-option *ngFor="let option of filterOptionsForHeaderKey" [value]="option">
                {{option}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
          <mat-form-field class="col-md-8" appearance="outline">
            <mat-label for="value"> Value </mat-label>
            <input matInput name="value" #headervalue (keyup)="onHeadersValue($event)" [matAutocomplete]="headersvalueauto">
            <mat-autocomplete #headersvalueauto="matAutocomplete">
              <mat-option *ngFor="let option of filterOptionsForHeaderValue" [value]="option">
                {{option}}
              </mat-option>
            </mat-autocomplete>
          </mat-form-field>
          <button mat-icon-button type="button" (click)="onAdd(headerkey, headervalue)">
            <mat-icon color="primary">add_circle</mat-icon>
          </button>
        </div>
      </mat-tab>
      <mat-tab label="Response">
        <div class="mt-1 row float-right">
          <small>Time: {{responseTime}}</small>
          <small class="ml-2">Status Code: {{statusCode}}</small>
        </div>
        <mat-form-field class="col-md-12 mt-2" appearance="outline">
          <mat-label for="response">Response</mat-label>
          <textarea matInput name="response" rows="15" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" formControlName="response"></textarea>
        </mat-form-field>
      </mat-tab>
    </mat-tab-group>
  </div>
</form>

menu/menu.component.ts
import { Component } from '@angular/core';
import { BreakpointObserver, Breakpoints, BreakpointState } from '@angular/cdk/layout';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { APIService } from '../shared/api.service';

@Component({
  selector: 'app-menu',
  templateUrl: './menu.component.html',
  styleUrls: ['./menu.component.css']
})
export class MenuComponent {

  items = [];

  selectedService: string;

  isHandset$: Observable<boolean> = this.breakpointObserver.observe(Breakpoints.Handset)
    .pipe(
      map(result => result.matches)
    );

  constructor(private breakpointObserver: BreakpointObserver, private apiService: APIService) {
    this.apiService.menuItems.subscribe(
      (items: any) => this.items = items
    );
     this.apiService.fetchServicesList()
      .subscribe( res => {
        this.apiService.fetchMenuItems();
        this.apiService.fetchServiceNames();
      });
  }

  onExpand(id) {
    this.items[id].expanded = !this.items[id].expanded;
  }

  onSelect(systemId, serviceId) {
    this.selectedService = systemId + '_' + serviceId;
    this.apiService.selectAPIByID(this.selectedService);
  }

  onNewService() {
    this.apiService.newService();
  }

  onDelete(e) {
    const systemId = e.split('_')[0];
    const serviceId = e.split('_')[1];
    const systemindex = this.items.findIndex(system => system.id.toString() === systemId.toString());
    const serviceindex = this.items[systemindex].services.findIndex(service => service.id.toString() === serviceId.toString());
    this.items[systemindex].services.splice(serviceindex, 1);
  }

}


menu/menu.component.html
<!-- *ngIf="isHandset$ | async" -->
<mat-toolbar color="primary" class="mat-elevation-z2" style="display: fixed">
  <button type="button" aria-label="Toggle sidenav" mat-icon-button (click)="drawer.toggle()" style="outline: none">
    <mat-icon aria-label="Side nav toggle icon">menu</mat-icon>
  </button>
  <span> REST API </span>
  <span style="flex: 1 1 auto"></span>
  <button mat-icon-button [matMenuTriggerFor]="menu" style="outline: 0">
    <mat-icon>more_vert</mat-icon>
  </button>
  <mat-menu #menu="matMenu">
    <button mat-menu-item style="outline: 0" (click)="onNewService()">New Service</button>
  </mat-menu>
</mat-toolbar>
<mat-sidenav-container class="sidenav-container mt-2">

  <mat-sidenav #drawer class="sidenav mat-shadow mt-1" fixedInViewport="false" [attr.role]="(isHandset$ | async) ? 'dialog' : 'navigation'"
    [mode]="(isHandset$ | async) ? 'over' : 'side'" [opened]="!(isHandset$ | async)">
    <!-- <mat-toolbar color="warn">RESTAPI</mat-toolbar> -->

    <mat-nav-list>
      <app-search></app-search>
      <div *ngFor="let item of items; let i = index" class="mt-3">
        <a mat-list-item (click)="onExpand(i)"> {{item.name}} <span style="flex: 1 1 auto"></span>
          <mat-icon>expand_more</mat-icon>
        </a>
        <div *ngIf="item.expanded">
          <div *ngFor="let service of item.services; ">
            <a class="pl-3" mat-list-item (click)="onSelect(item.id,service.id)"> {{service.name}} </a>
          </div>
        </div>
      </div>

      <!--  <a class="pl-3" mat-list-item >Link 1 <span style="flex: 1 1 auto"></span><mat-icon>expand_more</mat-icon></a>
        <a class="pl-3" mat-list-item >Link 1 <span style="flex: 1 1 auto"></span><mat-icon>expand_more</mat-icon></a> -->

    </mat-nav-list>
  </mat-sidenav>
  <mat-sidenav-content>
    <app-menu-content (delete)="onDelete($event)"></app-menu-content>
    <!-- Add Content Here -->
  </mat-sidenav-content>
</mat-sidenav-container>


menu/menu-content/menu-content.component.ts
import { Component, OnInit, Output, EventEmitter } from '@angular/core';
import { APIService } from '../../shared/api.service';

@Component({
  selector: 'app-menu-content',
  templateUrl: './menu-content.component.html',
  styleUrls: ['./menu-content.component.css']
})
export class MenuContentComponent implements OnInit {

  tabs = [];

  names = [];

  selectedTab = 0;

  servicemenu;

  @Output() delete = new EventEmitter();

  constructor(private apiService: APIService) { }

  ngOnInit() {
    this.apiService.names.subscribe( (res: any) => this.names = res);
    this.apiService.selectedAPIId.subscribe(
      serviceId => {
        if (serviceId === undefined) {
          this.tabs.push({ id: serviceId, name: 'New' });
          this.selectedTab = this.tabs.length;
          this.selectedTab++;
        } else {
          const tabIdx = this.tabs.findIndex(tab => tab.id === serviceId);
          if (tabIdx === -1) {
            this.tabs.push({ id: serviceId, name: this.apiService.fetchNamesById(serviceId) });
            this.selectedTab = this.tabs.length;
            this.selectedTab++;
          } else {
            this.selectedTab = tabIdx;
          }
        }
      });
  }

  onClose(idx) {
    this.tabs.splice(idx, 1);
  }

  onDelete(idx) {
    this.delete.emit(this.tabs[idx].id);
  }

}

menu/menu-content/menu-content.component.html
<div class="col-md-12">
  <mat-card class="pt-1 mt-1">
    <mat-card-content>
      <div *ngIf="tabs.length === 0; else content">
        <div style="display: flex; justify-content: center; margin: 10px">
          <mat-card *ngFor="let sys of names" class="m-2">
            <mat-card-header>{{sys.systemName}}</mat-card-header>
            <mat-card-content class="m-2 p-2">
              <ul *ngFor="let srv of sys.serviceNames">
                <li>{{srv}}</li>
              </ul>
            </mat-card-content>
          </mat-card>
        </div>
      </div>
      <ng-template #content>
        <mat-tab-group [color]="'accent'" [backgroundColor]="" [selectedIndex]="selectedTab">
          <div *ngFor="let tab of tabs; let i = index">
            <mat-tab>
              <ng-template mat-tab-label>
                <strong> {{tab.name}} &nbsp;&nbsp;&nbsp;</strong>
                <mat-icon style="cursor: pointer;" (click)="onClose(i)">close</mat-icon>
              </ng-template>
              <app-api-details [serviceContent]="tab.id" (delete)="onDelete(i)"></app-api-details>
            </mat-tab>
          </div>
        </mat-tab-group>
      </ng-template>
    </mat-card-content>
  </mat-card>
</div>

menu/search/search.component.ts
import { Component, OnInit } from '@angular/core';

import { Observable, Subject } from 'rxjs';
import { map, debounceTime, filter, distinctUntilChanged, switchMap } from 'rxjs/operators';
import { FormGroup, FormControl, Validators } from '@angular/forms';
import { APIService } from '../../shared/api.service';

@Component({
  selector: 'app-search',
  templateUrl: './search.component.html',
  styleUrls: ['./search.component.css']
})
export class SearchComponent implements OnInit {

  $searchString = new Subject();

  form: FormGroup = new FormGroup({
    search : new FormControl(null)
  });

  searchString;

  constructor(private apiService: APIService) {
    this.$searchString.pipe(
      map(e => console.log(e)),
      // filter((text) => text.length > 0),
      debounceTime(10),
      distinctUntilChanged(),
      // switchMap( () => conso)
    );
    this.$searchString.subscribe( s => {
      // s.pipe()
      console.log(s);
    })
    ;
  }

  ngOnInit() {
  }

  onSearch() {
    console.log(this.form.get('search').value);
    console.log(this.apiService.fetchMenuItemsBySearch(this.form.get('search').value) );
  }

  onClearSearch() {
    this.searchString = '';
    this.form.reset();
    this.apiService.fetchMenuItems();
  }

}

menu/search/search.component.html
<form [formGroup]="form" (ngSubmit)="onSearch()">
  <mat-form-field class="col-md-12">
    <input matInput type="text" id="search" name="search" placeholder="looking for ?" formControlName="search" [(ngModel)]="searchString">
  <!--  <button mat-button *ngIf="searchString" matSuffix mat-icon-button aria-label="Clear" (click)="onClearSearch()">
      <mat-icon>close</mat-icon>
    </button> -->
    <mat-icon matSuffix mat-icon-button aria-label="Clear" style="font-size: 100%; cursor: pointer;" *ngIf="searchString" (click)="onClearSearch()">close</mat-icon>
  </mat-form-field>
</form>
<mat-divider></mat-divider>



server/services.json
[
  {
    "name": "System 1",
    "id": 1,
    "services": [
      {
        "id": 1,
        "name": "Service 1",
        "description": "blah blah blah",
        "url": "google1.com",
        "method": "POST",
        "headers": [],
        "sampleRequest": "",
        "sampleResponse": ""
      },
      {
        "id": 2,
        "name": "Service 2",
        "description": "blah blah blah",
        "url": "google2.com",
        "method": "POST",
        "headers": [],
        "sampleRequest": "",
        "sampleResponse": ""
      },
      {
        "id": 3,
        "name": "Service 3",
        "description": "blah blah blah",
        "url": "google3.com",
        "method": "POST",
        "headers": [],
        "sampleRequest": "",
        "sampleResponse": ""
      },
      {
        "id": 4,
        "name": "Service 4",
        "description": "blah blah blah",
        "url": "google4.com",
        "method": "POST",
        "headers": [],
        "sampleRequest": "",
        "sampleResponse": ""
      },
      {
        "id": 5,
        "name": "Service 5",
        "description": "blah blah blah",
        "method": "POST",
        "url": "google5.com",
        "headers": [],
        "sampleRequest": "",
        "sampleResponse": ""
      }
    ]
  },{
    "name": "System 2",
    "id": 2,
    "services": [
      {
        "id": 6,
        "name": "Service 6",
        "description": "blah blah blah",
        "url": "google6.com",
        "method": "POST",
        "headers": [],
        "sampleRequest": "",
        "sampleResponse": ""
      },
      {
        "id": 7,
        "name": "Service 7",
        "description": "blah blah blah",
        "url": "google7.com",
        "method": "POST",
        "headers": [],
        "sampleRequest": "",
        "sampleResponse": ""
      },
      {
        "id": 8,
        "name": "Service 8",
        "description": "blah blah blah",
        "url": "google8.com",
        "method": "POST",
        "headers": [],
        "sampleRequest": "",
        "sampleResponse": ""
      },
      {
        "id": 9,
        "name": "Service 9",
        "description": "blah blah blah",
        "url": "google9.com",
        "method": "POST",
        "headers": [],
        "sampleRequest": "Test1",
        "sampleResponse": "Testt1"
      },
      {
        "id": 10,
        "name": "Service 10",
        "description": "blah blah blah",
        "url": "google10.com",
        "method": "POST",
        "headers": [],
        "sampleRequest": "Test2",
        "sampleResponse": "Testst3"
      }
    ]
  }
]

server/router.ts
import { Router } from 'express';
import * as request from 'request';
import * as fs from 'fs';
import { DB } from './db.model';

import { default as db } from './services.json';

export const router = Router();

router.get('/services', (req, res) => {
  res.json(db);
});

router.post('/save', (req, res) => {
  save(req.body, res);
});

router.post('/delete', (req, res) => {
  deleteService(req.body, res);
});

router.post('/send', (req, res) => {
  sendRequest(req.body, res);
});

function save(data, res) {
  if (data.systemId === null) {
    console.log('New service request');
    db.findIndex( (system: DB) => system.name.includes(data.name)) > -1 ? newService(data) : newSystem(data);
  } else {
    existingService(data);
  }
  fs.writeFileSync('./server/services.json', JSON.stringify(db, undefined, 4));
  res.send(db);
}

function newSystem(data) {
  db.push({
    id: db.length + 1,
    name: data.systemName,
    services: [{
      id: 1,
      name: data.serviceName,
      description: data.description,
      url: data.url,
      method: data.method,
      headers: data.headers,
      sampleRequest: data.sampleRequest,
      sampkeResponse: data.sampleResponse
    }]
  });
}

function newService(data) {
  const systemindex = db.findIndex( (system: DB) => system.name === data.name);
  db[systemindex].services.push({
    id: data.serviceId,
    name: data.serviceName,
    description: data.description,
    url: data.url,
    method: data.method,
    headers: data.headers,
    sampleRequest: data.sampleRequest,
    sampleResponse: data.sampleResponse
  });
}

function existingService(data) {
  try {
    db.forEach((system: DB, systemindex) => {
      console.log(system);
      if (system.id.toString() === data.systemId.toString()) {
        const serviceindex = system.services.findIndex(service => service.id.toString() === data.serviceId.toString());
        db[systemindex].id = data.systemId;
        db[systemindex].name = data.systemName;
        db[systemindex].services[serviceindex].id = data.serviceId;
        db[systemindex].services[serviceindex].method = data.method;
        db[systemindex].services[serviceindex].url = data.url;
        db[systemindex].services[serviceindex].headers = data.headers;
        db[systemindex].services[serviceindex].name = data.serviceName;
        db[systemindex].services[serviceindex].sampleRequest = data.sampleRequest;
        db[systemindex].services[serviceindex].sampleResponse = data.sampleResponse;
        db[systemindex].services[serviceindex].description = data.description;
      }
    });
  } catch (e) {
    console.log(e);
  }

}

function deleteService(req, res) {
  const id = req.id;
  const systemId = id.split('_')[0];
  const serviceId = id.split('_')[1];
  const systemindex = db.findIndex( system => system.id.toString() === systemId.toString());
  const serviceindex = db[systemindex].services.findIndex( service => service.id.toString() === serviceId.toString());
  db[systemindex].services.splice(serviceindex, 1);
  fs.writeFileSync('./server/services.json', JSON.stringify(db, undefined, 4));
  res.send(db);
}

function sendRequest(fdata, res) {

  const headers = fdata.header.reduce( (headersObj, header) => {
    headersObj[header.key] = header.value;
    return headersObj;
  }, {});

  const options = {
    method: fdata.method,
    url: fdata.url,
    body: fdata.body || null,
    headers: headers,
    time: true
  };

  request(options, (err, response, body) => {

    let _body = '';

    try {
      _body = JSON.parse(body);
    } catch (e) {
      _body = body;
    }

    res.send({
      body: _body,
      time: response.elapsedTime,
      statusCode: response.statusCode
    });

  });
}


server/db.model.ts
export class DB1 {
  constructor(
    public systems: DB[]
  ) {}
}

export class DB {
  constructor(
    public id: number,
    public name: string,
    public services: Service[]
  ) {}
}

export class Service {
  constructor(
    public id: number,
    public name: string,
    public description: string,
    public url: string,
    public method: string,
    public headers: any,
    public sampleRequest: string,
    public sampleResponse: string
  ) {}
}


server.ts
// These are important and needed before anything else
import 'zone.js/dist/zone-node';
import 'reflect-metadata';

import { renderModuleFactory } from '@angular/platform-server';
import { enableProdMode } from '@angular/core';

import * as express from 'express';
import * as bodyParser from 'body-parser';
import * as cors from 'cors';
import { join } from 'path';
import { readFileSync } from 'fs';

import {router} from './server/router';

// Import module map for lazy loading
import { provideModuleMap } from '@nguniversal/module-map-ngfactory-loader';

const { AppServerModuleNgFactory, LAZY_MODULE_MAP } = require('./dist/server/main');

// Faster server renders w/ Prod mode (dev mode never needed)
enableProdMode();

// Express server
const app = express();

const PORT = process.env.PORT || 4000;
const DIST_FOLDER = join(process.cwd(), 'dist');

// Our index.html we'll use as our template
const template = readFileSync(join(DIST_FOLDER, 'browser', 'index.html')).toString();

app.engine('html', (_, options, callback) => {
  renderModuleFactory(AppServerModuleNgFactory, {
    // Our index.html
    document: template,
    url: options.req.url,
    // DI so that we can get lazy-loading to work differently (since we need it to just instantly render it)
    extraProviders: [
      provideModuleMap(LAZY_MODULE_MAP)
    ]
  }).then(html => {
    callback(null, html);
  });
});

app.set('view engine', 'html');
app.set('views', join(DIST_FOLDER, 'browser'));

// Server static files from /browser
app.get('*.*', express.static(join(DIST_FOLDER, 'browser')));

// All regular routes use the Universal engine
app.get('/', (req, res) => {
  res.render(join(DIST_FOLDER, 'browser', 'index.html'), { req });
});

app.use(cors());
app.use(function (req, res, next) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, PATCH, DELETE');
  res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With,content-type');
  res.setHeader('Access-Control-Allow-Credentials', true);
  next();
});
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use('/server', router);

// Start up the Node server
app.listen(PORT, () => {
  console.log(`Node server listening on http://localhost:${PORT}`);
});

webpack.server.config.js
const path = require('path');
const webpack = require('webpack');

module.exports = {
  entry: { server: './server.ts' },
  resolve: { extensions: ['.js', '.ts'] },
  target: 'node',
  mode: 'none',
  // this makes sure we include node_modules and other 3rd party libraries
  externals: [/node_modules/],
  output: {
    path: path.join(__dirname, 'dist'),
    filename: '[name].js'
  },
  module: {
    rules: [{ test: /\.ts$/, loader: 'ts-loader' }]
  },
  plugins: [
    // Temporary Fix for issue: https://github.com/angular/angular/issues/11580
    // for 'WARNING Critical dependency: the request of a dependency is an expression'
    new webpack.ContextReplacementPlugin(
      /(.+)?angular(\\|\/)core(.+)?/,
      path.join(__dirname, 'src'), // location of your src
      {} // a map of your routes
    ),
    new webpack.ContextReplacementPlugin(
      /(.+)?express(\\|\/)(.+)?/,
      path.join(__dirname, 'src'),
      {}
    )
  ]
};


